#include <SPI.h>
#include <MFRC522v2.h>
#include <MFRC522DriverSPI.h>
#include <WiFi.h>
#include <MFRC522DriverPinSimple.h>
#include <MFRC522Debug.h>
#include <WebServer.h>
#include <ArduinoJson.h>
// #include <ESP32Servo.h>

// Pin Definitions
#define Red_pin 22
#define Green_pin 13
#define Lock_pin 26
#define buzzer_pin 33
// #define servo_pin 32

// Servo configuration
// Servo doorServo;  // Create servo object
// #define SERVO_CLOSED_POS 0    // Servo position for closed/locked door (degrees)
// #define SERVO_OPEN_POS 90

// RFID Pins
MFRC522DriverPinSimple ss_pin(5);
MFRC522DriverSPI driver{ss_pin};
MFRC522 mfrc522{driver};

// WiFi Credentials
const char* ssid = "Sm-f snap";
const char* password = "samsam2025";

// Server and system status
bool serverRunning = false;
bool entryAllowed = true;
int availableSeats = 30;

// Store last 20 attendees (adjust as needed based on ESP32 memory)
#define MAX_ATTENDEES 20
struct Attendee {
  String uid;
  String timestamp;
};
Attendee attendees[MAX_ATTENDEES];
int attendeeCount = 0;

WebServer server(80); // Default HTTP port

// Dashboard HTML content (stored in program memory to save RAM)
const char DASHBOARD_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecturer Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0 auto;
      max-width: 600px;
      padding: 20px;
    }
    .card {
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .flex {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .button {
      padding: 8px 12px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    .button.outline {
      background-color: transparent;
      border: 1px solid #007bff;
      color: #007bff;
    }
    ul {
      list-style-type: disc;
      padding-left: 20px;
    }
    .toggle-switch {
      width: 50px;
      height: 25px;
      border-radius: 25px;
      position: relative;
      cursor: pointer;
    }
    .toggle-thumb {
      width: 23px;
      height: 23px;
      background-color: white;
      border-radius: 50%;
      position: absolute;
      top: 1px;
      transition: all 0.3s;
    }
    .toggle-on {
      background-color: green;
    }
    .toggle-off {
      background-color: red;
    }
    .toggle-on .toggle-thumb {
      left: 26px;
    }
    .toggle-off .toggle-thumb {
      left: 1px;
    }
    .status-indicator {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 10px;
      color: white;
      font-size: 0.8rem;
      margin-left: 10px;
    }
    .status-online {
      background-color: green;
    }
    .status-offline {
      background-color: #888;
    }
  </style>
</head>
<body>
  <h1>Lecturer Dashboard</h1>
  <div class="flex">
    <h3>Door Control System</h3>
    <span id="connectionStatus" class="status-indicator status-online">Online</span>
  </div>

  <div class="card">
    <div class="flex">
      <div>
        <h2>Allow Entry</h2>
        <p>Toggle to control LED outside the hall</p>
      </div>
      <div id="entrySwitch" class="toggle-switch toggle-on" onclick="toggleEntry()">
        <div class="toggle-thumb"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="flex">
      <div>
        <h2>Available Seats</h2>
        <p id="seatCount" style="font-size: 2rem; color: green;">30</p>
      </div>
      <button class="button outline" onclick="syncData()">Sync</button>
    </div>
    <div>
      <button class="button" onclick="resetSeats()">Reset</button>
      <button class="button" onclick="adjustSeats(1)">+1</button>
      <button class="button" onclick="adjustSeats(-1)">-1</button>
    </div>
  </div>

  <div class="card">
    <h2>Attendees</h2>
    <ul id="attendeeList"></ul>
    <div class="flex">
      <button class="button" onclick="exportCSV()">Export List</button>
      <button class="button" onclick="resetAttendees()">Reset List</button>
    </div>
  </div>

  <script>
    let isEntryAllowed = true;
    let availableSeats = 30;
    let attendees = [];
    let isConnected = true;

    // Initialize the dashboard
    function init() {
      updateSeatDisplay();
      syncData();
      // Set up periodic syncing
      setInterval(syncData, 5000);
    }

    // Update the seat count display
    function updateSeatDisplay() {
      const seatCountElement = document.getElementById("seatCount");
      seatCountElement.innerText = availableSeats;
      
      // Change color based on availability
      if (availableSeats <= 0) {
        seatCountElement.style.color = "red";
      } else if (availableSeats < 5) {
        seatCountElement.style.color = "orange";
      } else {
        seatCountElement.style.color = "green";
      }

      // Disable entry toggle if seats are full
      if (availableSeats <= 0 && isEntryAllowed) {
        toggleEntry();
      }
    }

    // Render attendee list
    function renderAttendees() {
      const ul = document.getElementById("attendeeList");
      ul.innerHTML = attendees.length > 0 
        ? attendees.map((att, index) => `<li>${att.uid} (${att.timestamp})</li>`).join("")
        : "<li>No attendees recorded yet</li>";
    }

    // Toggle entry permission
    function toggleEntry() {
      if (availableSeats <= 0) {
        alert("Cannot allow entry when no seats are available!");
        return;
      }
      
      isEntryAllowed = !isEntryAllowed;
      const entrySwitch = document.getElementById("entrySwitch");
      entrySwitch.className = `toggle-switch ${isEntryAllowed ? "toggle-on" : "toggle-off"}`;
      
      // Send update to server
      updateServerStatus();
    }

    // Sync with server
    function syncData() {
      fetch('/api/status')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          isEntryAllowed = data.isEntryAllowed;
          availableSeats = data.availableSeats;
          attendees = data.attendees || [];
          
          // Update UI
          document.getElementById("entrySwitch").className = 
            `toggle-switch ${isEntryAllowed ? "toggle-on" : "toggle-off"}`;
          updateSeatDisplay();
          renderAttendees();
          updateConnectionStatus(true);
        })
        .catch(error => {
          console.error("Error syncing with server:", error);
          updateConnectionStatus(false);
        });
    }

    // Update connection status indicator
    function updateConnectionStatus(connected) {
      const statusElement = document.getElementById("connectionStatus");
      if (connected) {
        statusElement.textContent = "Online";
        statusElement.className = "status-indicator status-online";
      } else {
        statusElement.textContent = "Offline";
        statusElement.className = "status-indicator status-offline";
      }
    }

    // Send updated status to server
    function updateServerStatus() {
      fetch('/api/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          isEntryAllowed: isEntryAllowed,
          availableSeats: availableSeats
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log("Server updated successfully:", data);
        updateConnectionStatus(true);
      })
      .catch(error => {
        console.error("Error updating server:", error);
        updateConnectionStatus(false);
      });
    }

    // Export attendee list as CSV
    function exportCSV() {
      if (attendees.length === 0) {
        alert("No attendees to export!");
        return;
      }
      
      // Create CSV content
      const headers = "UID,Timestamp\n";
      const rows = attendees.map(att => `${att.uid},${att.timestamp}`).join("\n");
      const csv = headers + rows;
      
      // Download CSV
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'attendees.csv';
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
    }

    // Reset seat count
    function resetSeats() {
      availableSeats = 30;
      updateSeatDisplay();
      updateServerStatus();
    }

    // Adjust seat count
    function adjustSeats(delta) {
      availableSeats = Math.max(0, availableSeats + delta);
      updateSeatDisplay();
      updateServerStatus();
    }

    // Reset attendee list
    function resetAttendees() {
      if (attendees.length === 0) {
        return;
      }
      
      if (confirm("Are you sure you want to clear the attendee list?")) {
        fetch('/api/reset-attendees', {
          method: 'POST'
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          attendees = [];
          renderAttendees();
        })
        .catch(error => {
          console.error("Error resetting attendees:", error);
        });
      }
    }

    // Start the dashboard
    init();
  </script>
</body>
</html>
)rawliteral";

// Helper function to get current time as string (can be enhanced with RTC module)
String getTimeString() {
  unsigned long currentMillis = millis();
  int seconds = currentMillis / 1000;
  int minutes = seconds / 60;
  int hours = minutes / 60;
  
  // Format as HH:MM:SS
  char timeStr[9];
  sprintf(timeStr, "%02d:%02d:%02d", hours % 24, minutes % 60, seconds % 60);
  return String(timeStr);
}

// Add new attendee to the list
void addAttendee(String uid) {
  // Check if attendee already exists to avoid duplicates
  for (int i = 0; i < attendeeCount; i++) {
    if (attendees[i].uid == uid) {
      return; // Already registered
    }
  }
  
  // If list is full, shift everyone up to make room at the end
  if (attendeeCount >= MAX_ATTENDEES) {
    for (int i = 0; i < MAX_ATTENDEES - 1; i++) {
      attendees[i] = attendees[i + 1];
    }
    attendeeCount = MAX_ATTENDEES - 1;
  }
  
  // Add new attendee at the end
  attendees[attendeeCount].uid = uid;
  attendees[attendeeCount].timestamp = getTimeString();
  attendeeCount++;
  
  // Decrease available seats
  if (availableSeats > 0) {
    availableSeats--;
  }
}

// WiFi Connection Function with timeout
bool connectToWiFi(int timeout_seconds = 10) {
  Serial.println("Starting WiFi connection attempt...");
  WiFi.begin(ssid, password);
  
  int max_attempts = timeout_seconds * 2; // 2 attempts per second
  int attempts = 0;
  
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED && attempts < max_attempts) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi Connected!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
    return true;
  } else {
    Serial.println("\nWiFi connection FAILED! Continuing without WiFi.");
    // Disconnect WiFi to free up resources
    WiFi.disconnect(true);
    WiFi.mode(WIFI_OFF);
    return false;
  }
}

// Lock Door
void lockDoor() {
  digitalWrite(Lock_pin, LOW);         // Lock engaged
  // doorServo.write(SERVO_CLOSED_POS);   // Move servo to closed position
  Serial.println("Door Locked");
}

// Unlock Door
void unlockDoor() {
  digitalWrite(Lock_pin, HIGH);        // Lock released
  // doorServo.write(SERVO_OPEN_POS);     // Move servo to open position
  digitalWrite(buzzer_pin, HIGH);      // Sound buzzer when door opens
  delay(200);                          // Short beep
  digitalWrite(buzzer_pin, LOW);
  Serial.println("Door Unlocked");
}

// Update LED status based on entryAllowed
void updateLEDs() {
  if (entryAllowed) {
    digitalWrite(Green_pin, HIGH);     // Green ON when entry allowed
    digitalWrite(Red_pin, LOW);        // Red OFF
    // Sound buzzer for 4 seconds when entry is allowed
  } else {
    digitalWrite(Green_pin, LOW);      // Green OFF
    digitalWrite(Red_pin, HIGH);
         // Red ON when entry not allowed
  }
}

// Root page - serve the dashboard HTML
void handleRoot() {
  server.send(200, "text/html", DASHBOARD_HTML);
}

// Status API endpoint
void handleAPIStatus() {
  // Create JSON response with current status
  DynamicJsonDocument doc(2048); // Adjust size as needed
  doc["isEntryAllowed"] = entryAllowed;
  doc["availableSeats"] = availableSeats;
  
  // Add attendees as an array
  JsonArray attendeeArray = doc.createNestedArray("attendees");
  for (int i = 0; i < attendeeCount; i++) {
    JsonObject att = attendeeArray.createNestedObject();
    att["uid"] = attendees[i].uid;
    att["timestamp"] = attendees[i].timestamp;
  }
  
  // Serialize JSON to string
  String jsonResponse;
  serializeJson(doc, jsonResponse);
  
  server.send(200, "application/json", jsonResponse);
}

// Update API endpoint
void handleAPIUpdate() {
  // Check if we received valid JSON
  if (server.hasArg("plain")) {
    String body = server.arg("plain");
    DynamicJsonDocument doc(512);
    DeserializationError error = deserializeJson(doc, body);
    
    if (!error) {
      // Update system status from received data
      if (doc.containsKey("isEntryAllowed")) {
        entryAllowed = doc["isEntryAllowed"].as<bool>();
      }
      
      if (doc.containsKey("availableSeats")) {
        availableSeats = doc["availableSeats"].as<int>();
      }
      
      // Update hardware status based on entryAllowed
      updateLEDs();
      
      server.send(200, "application/json", "{\"success\":true}");
    } else {
      server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
    }
  } else {
    server.send(400, "application/json", "{\"error\":\"Missing body\"}");
  }
}

// Reset attendees endpoint
void handleResetAttendees() {
  // Clear attendee list
  attendeeCount = 0;
  server.send(200, "application/json", "{\"success\":true}");
}

// Unlock door endpoint
void handleUnlock() {
  unlockDoor();
  delay(2000);
  lockDoor();
  server.send(200, "application/json", "{\"success\":true}");
}

// Setup the web server routes
bool setupServer() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Cannot setup server: WiFi not connected");
    return false;
  }
  
  // Set up server routes
  server.on("/", HTTP_GET, handleRoot);
  server.on("/api/status", HTTP_GET, handleAPIStatus);
  server.on("/api/update", HTTP_POST, handleAPIUpdate);
  server.on("/api/reset-attendees", HTTP_POST, handleResetAttendees);
  server.on("/api/unlock", HTTP_GET, handleUnlock);
  
  // Start server
  server.begin();
  Serial.println("HTTP server started");
  Serial.print("Dashboard available at http://");
  Serial.println(WiFi.localIP());
  return true;
}

void setup() {
  Serial.begin(115200);
  delay(1000); // Give serial monitor time to connect
  
  Serial.println("\n\n===== ESP32 RFID Access Control with Dashboard =====");
  
  // Setup Pins
  pinMode(Red_pin, OUTPUT);
  pinMode(Green_pin, OUTPUT);
  pinMode(Lock_pin, OUTPUT);
  pinMode(buzzer_pin, OUTPUT);
  
  // Initialize Servo
  // ESP32PWM::allocateTimer(0); // Allocate timer 0
  // doorServo.setPeriodHertz(50); // Standard 50Hz servo
  // doorServo.attach(servo_pin, 500, 2400); // Attaches servo on pin with min/max pulse width
  lockDoor(); // Start with door locked
  updateLEDs(); // Set initial LED state
  
  // First initialize WiFi - do this BEFORE SPI
  // Try to connect with 10 second timeout
  bool wifiConnected = connectToWiFi(10);
  
  // Setup server if WiFi is connected
  if (wifiConnected) {
    serverRunning = setupServer();
    Serial.println(serverRunning ? "Server setup complete" : "Server setup failed, continuing with RFID only");
  } else {
    Serial.println("Proceeding with RFID functionality only");
  }
  
  // Then initialize SPI for RFID
  Serial.println("Initializing RFID reader...");
  SPI.begin(18, 19, 23, 5);  // Required before RFID init
  
  // Small delay before initializing RFID
  delay(100);
  
  mfrc522.PCD_Init();        // Init RFID
  
  Serial.println("RFID reader status:");
  MFRC522Debug::PCD_DumpVersionToSerial(mfrc522, Serial);
  Serial.println("Ready! Scan RFID card to unlock door...");
}

void loop() {
  // Handle server requests if server is running
  if (serverRunning) {
    server.handleClient();
  }
  
  // Wait for new card
  if (!mfrc522.PICC_IsNewCardPresent()) {
    delay(50); // Small delay to prevent CPU hogging
    return;
  }
  
  // Wait for full card read
  if (!mfrc522.PICC_ReadCardSerial()) {
    return;
  }
  
  // Print UID + card info
  Serial.println("Card detected!");
  
  // Format card UID as string
  String cardUID = "";
  for (byte i = 0; i < mfrc522.uid.size; i++) {
    if (mfrc522.uid.uidByte[i] < 0x10) {
      cardUID += "0";
    }
    cardUID += String(mfrc522.uid.uidByte[i], HEX);
  }
  cardUID.toUpperCase();
  
  Serial.print("Card UID: ");
  Serial.println(cardUID);
  
  // Check if entry is allowed
  if (entryAllowed && availableSeats > 0) {
    // Add to attendee list
    addAttendee(cardUID);
    
    // Access control: unlock then lock
    unlockDoor();
    
    // Flash green LED to indicate successful scan
    for (int i = 0; i < 3; i++) {
      digitalWrite(Green_pin, LOW);
      delay(200);
      digitalWrite(Green_pin, HIGH);
      delay(200);
    }
    
    delay(2000);
    lockDoor();
  } else {
    // Entry denied - flash red LED
    for (int i = 0; i < 3; i++) {
      digitalWrite(buzzer_pin, HIGH);
      digitalWrite(Red_pin, LOW);
      delay(200);
      digitalWrite(Red_pin, HIGH);
      delay(1300);
      digitalWrite(buzzer_pin, LOW);

    }
    Serial.println("Entry denied: " + String(entryAllowed ? "No seats available" : "Entry not allowed"));
  }
  
  // Halt PICC and stop encryption
  mfrc522.PICC_HaltA();
  mfrc522.PCD_StopCrypto1();
}

